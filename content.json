{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"KT S/W Developer Conference 2019 후기","text":"KT S/W Developer Conference 2019👨🏻‍💻늦은 시기 개발자가 되겠다는 생각으로 지원한 중소기업 첫 면접에서 파이콘을 알게 되었으나 이미 티켓이 매진되었고 네이버와 카카오는 추첨 탈락으로 좌절하고 있을 때 KT에서 주최하는 S/W Developer Conference 2019를 알게 되었고 덕분에 인생 처음으로 개발자 컨퍼런스에 다녀왔다. 파이콘(PYCON)파이콘은 세계 각국의 파이썬 프로그래밍 언어 커뮤니티에서 주관하는 비영리 컨퍼런스다. 프로그램은 세가지 주제들로 나눠서 진행되었다. TRACK I : 5G Technology TRACK II : Software Technology TRACK III : AI with GiGA Genie 아침 일찍 서울로 출발해 컨퍼런스 장소인 TheK 호텔 서울에 11시 반에 도착했다. 전날 행사 사전 등록자 중 선착순으로 선물을 준다고 문자가 와서 그런지 행사장인 거문고홀에 올라갔을 땐 끝이 보이지 않는 줄이 나를 기다리고 있었다. 다양한 연령대의 사람들이 줄 서 있었고 학생들도 많았다. 내가 학생 때 알았더라면 더 좋았을 텐데… 항상 후회는 늦는법이다.🤔 12시 땡 하고 참가 등록 후 둘러보니 전시 체험 부스들과 반대편엔 쿠키와 커피가 준비되어있었다. 어서 자리를 잡아야 할 것 같아서 점심을 먹지 못한 허기진 나의 배를 채우기 위해 조금의 쿠키를 들고 자리로 이동했다. KT에서 예상보다 사람들이 많이 참석해서 추가로 의자를 준비했음에도 불구하고 자리가 없어 서서 듣는 분들도 많았다. KeynoteKeynote 1 - KT 소프트웨어 개발 추진 전략 및 방향간단한 환영사 후 KT IoT 플랫폼 개발 담당자 조성은 님의 KT 소프트웨어 개발 추진 전략 및 방향으로 시작되었다. 짧은 KT 소개와 KT 중점 개발, KT 개발 프레임워크, SW 개발자 문화를 말씀해 주셨다. KT 중점 개발 iot 많은 thing 들을 비용 효율적으로 연결 AI GIS 5G 몰입형 미디어 5G Connected Car KT 개발 프레임워크 Pizzeria Framework SW 개발자 문화 Agile 개발 문화 정착 &amp; Fun 개발, 코칭, 소통하는 Agile Culture 프로그램 Keynote 2 - 한국에서도 애자일과 DevOps 할 수 있다두 번째로는 한국 IBM 공진기 님께서 한국에서도 애자일(Agile)과 DevOps 할 수 있다라는 주제로 말씀해주셨다. Agile애자일이란 ‘기민한, 민첩한’이라는 의미로 작업 계획을 짧은 단위로 세우고 시제품을 만들어 나가는 사이클을 반복함으로써 고객의 요구 변화에 유연하고 신속하게 대응하며, 사무환경에서 부서 간 경계를 허물고 팀원에게 의사 설정 권한을 부여해 신속하게 업무를 진행하는 방법을 뜻한다.DevOps데브옵스는 소프트웨어의 개발과 운영의 합성어로서, 소프트웨어 개발자와 정보기술 전문가 간의 소통, 협업 및 통합을 강조하는 개발 환경이나 문화를 말한다 이후 Tools(SCM, Editor, Issue &amp; Communications), 개발 환경, Open &amp; Share, Organization &amp; KPI, Structure의 과거와 현재를 비교해주셨고 결과적으로 아래표가 도출되었다. [Summary] Company Team Individual 비용보다 생산성에 집중한 근무환경 도입 혁신과 공유를 장려하는 도전적인 KPI 도입 끊임없는 공부를 통한 자기 계발 분리조직으로 흔들리지않는 Agile&amp;DevOps 변화를 두려워하지 않는 조직문화 도입 변화를 이끌어내는 적극적인 태도 문화 전파를 통한 조직 체질 개선 노력 신기술과 도구를 도입하여야 팀 역량 강화 그래도 안바뀌면..? 두 개의 Keynote가 끝나고 20분간 Coffee Break를 가졌다. 듣고 싶은 TRACK의 룸으로 이동하시는 분들이 많아 복도는 퇴근시간 전철에 타있는 기분이었다.😵 쉴 때 복도에 나갔더니 명절에도 남자 화장실에 줄서있는걸 보지 못했는데… 그 정도로 사람이 많았고 그에 비해 화장실이 부족한게 조금 아쉬웠다. TRACK III - AI with GiGA Genie 평소 AI에 관심이 많았고 잠시 공부도 했기 때문에 어쩌다 보니 TRACK 3만 들었다. TRACK III - 1. GiGA Genie Eco - AMK + GenieBlock, GiGA Genie InsideTRACK 3의 첫 번째 시간은 GiGA Genie Eco - AMK + GenieBlock, GiGA Genie Inside라는 주제로 KT 융합기술원의 박성준 책임연구원님께서 발표해주셨다. 간략한 GiGA Genie와 AI MAKERS KIT을 소개해 주셨다. AI MAKERS KIT 이란?AI Do it Yourself 개념의 AI 개발 Kit로 개발자가 직접 조립 및 코딩을 통해 자기만의 AI 단말/서비스를 제작할 수 있도록 H/W 와 인공지능 API 제공 AI Makers Kit로 서드파티를 위한 인공지능 기술을 제공하며 플랫폼 기반 Cloud AI API로 AI Device를 개발할 수 있다. 기가지니 호출어/음성인식/대화/음성합성 API 제공하며, 응용 단말/서비스 개발을 위한 Documents 및 샘플 코드도 제공된다. 한마디로 직접 GiGA Genie를 만들 수 있다는 것이다. [참고] AI Makers Kit 소개 사이트 와 AI Makers Kit GitHub ‘인공지능’, ‘사물인터넷’, ‘빅데이터’ 등의 세상의 기술들을 쉽게 학습하고 구현할 수 있는 소프트웨어 코딩 교육 플랫폼인 Genie Block (https://genieblock.kt.co.kr) 과 서드파티 단말에서 기가지니 서비스를 이용할 수 있도록 지원하는 시스템인 GiGA Genie inside 의 설명을 끝으로 발표가 마무리되었다. 특히 Genie Block은 AI MAKERS KIT을 활용해 실제 환경에서 대화하고 동작하도록 구현할 수 있다고 한다. 블록코딩블록을 쌓아서 프로그램을 경험할 수 있는 교육용 오픈소스 프로그래밍 도구GiGA Genie inside서드파티 단말에서 기가지니 서비스를 이용할 수 있도록 지원하는 시스템으로, AI 기술이 없는 서드파티도 AI 단말 개발 가능 TRACK III - 2. GiGA Genie는 왜 Web App을 선택했는가?두 번째 시간에는 KT 소프트웨어 개발단의 이정호 님께서 GiGA Genie는 왜 Web App을 선택했는가? 라는 주제로 발표해주셨다. Front-end 부분이었지만 관심 있는 Web App이라 열심히 들었다. Web App의 장점 실행 환경의 자유로움 브라우저만 있다면 실행 가능 설치 과정이 필요 없고 업데이트가 손쉬움 브라우저에 URL만 입력하면 사용 가능 웹서버에 배포하면 모든 사용자가 즉시 업데이트 일단 GiGA Genie에서 Web App이 필요한 이유는 버전관리 문제라고 하셨다. GiGA Genie는 각각의 운영체제(Linux 기반 or Custom Android)가 다르기 때문에 버전관리를 위해 Web App이 필요했다. 하지만 Web App을 개발하자니 기존 웹 서비스의 인터페이스인 키보드, 마우스와는 달리 GiGA Genie의 인터페이스는 리모컨과 목소리라서 기존과 사용자 인터페이스가 달라 어려움이 있었다고 하셨다. 이후 Web App에 사용할 수 있는 Javascript 라이브러리로 제공되는 GiGA Genie Service SDK를 설명해주시면서 같이 제공되는 API의 종류도 설명해주셨다. [제공 API 종류] Namespace 설명 gigagenie.init API 초기화 및 App 상태정보 제공 및 관리 gigagenie.voice 음성인식/TTS 등 음성 인터페이스 제어 gigagenie.appdata Web Service 제공에 필요한 데이터 저장/관리 gigagenie.appinfo GiGA Genie 사용자 정보 및 App 정보 조회/관리 현재 기가지니의 총 90여개 B2C Service 중 75% 는 Web Application이라고 한다. 그중 엔터테인먼트, 키즈 서비스, 라이프스타일 그리고 금융은 100% Web Application으로 제공된다고 한다. TRACK III - 3. GiGA Genie를 위한 Text Analytics 기술세 번째 시간은 KT 융합기술원의 류휘정 님께서 GiGA Genie를 위한 Text Analytics 기술을 발표해주셨다. 문장/문서 분류(Text Classification) 기술은 현재 GiGA Genie와 상담 Assist에서 사용 중이라고 하셨다. 텍스트 분류(Text Classification) 기술은 모두 Deep Neural Network(딥 러닝)을 이용 중이라고 하셨다. 딥 러닝 적용을 위해 해결해야 할 현실적 문제들 Data Embedding Network Hyper parameters 특히 문장분석에서는 BERT 기반 텍스트 분류를 사용해 문장 분류 성능을 상승시켰다고 하셨다. BERT(Bidirectional Encoder Representations from Transformers)구글이 공개한 인공지능(AI) 언어모델 ‘BERT’는 자연 언어 처리(NLP) AI의 최첨단 딥러닝 모델이다.참고 사이트 Text Analytics 기술 소개 문장분석 감정분석 기계번역 MRC 텍스트와 목소리 톤의 차이에서 오는 문제를 해결하기 위해 복합 감성 인지(Emotion Recognition) 기술도 추가되었다. 복합 감성 인지 기술을 위해 Multi Modal학습 방법을 도입했다고 한다. Text Model + Voice Model = MultiModal Model Text Model 보다 30%* ,Voice Model 보다 *55%** 성능 향상을 보였다 감성인지 성능 변화(복합 데이터의 힘) Voice Text –&gt; Text/BERT –&gt; MultiModal Model 기계 독해 기술(Machine Reading Comprehension) 을 추가해 GiGA Genie는 단순한 값만 알려주는 것이 아닌 문서를 대신 읽어주는 AI가 되었다. ex) GiGA Genie사람 : 방탄소년단 리더가 누구야?GiGA Genie : 방탄소년단의 리더는 RM입니다. 상담 Assist사람 : KT 더블할인 멤버십으로 CGV 얼마나 할인받아요?Assist : 최대 동반 1인까지 8천 원 할인받으실 수 있어요. 마지막으로 Text Analytics 엔징 패키징이 개발중이고 올해 3분기에 개발 완료된다고 하셨다. Text Analytics는 최근 매우 빠르게 발전하고 있어서 향후 사람보다 더 정확히 분류해낼것으로 보인다고 하셨다. Text Analytics 엔진 패키징 데이터등록 -&gt; 모델학습 -&gt; 서비스(API) 시작 -&gt; 모니터링/통계 TRACK III - 4. GIGA GENIE 음성/대화 품질 향상을 위한 독음 데이터 가공 자동화대망의 마지막시간!! KT 박성찬 님께서 TRACK III - 4. GIGA GENIE 음성/대화 품질 향상을 위한 독음 데이터 가공 자동화를 발표해주셨다. 사실 듣기 전엔 ‘독음 데이터가 왜 필요하지?’라고 생각했는데 음성인식 AI에는 정말 꼭 필요 작업이란걸 알게 되었다. 독음소리를 기반으로 한 문자 시스템을 다른 문자 시스템으로 대응시키는 과정 솔루션 배경 및 필요성 GiGA Genie에게 BTS의 Wake Up을 들려달라고 했지만 Welcome이 나온 사례 자동화 요구사항 독음과정을 100% 수작업에 의존 -&gt; AI가 독음 과정을 수행하고 사람이 보정 Business Understanding 사업요구사항 독음 결과가 음성인식/대화에서의 품질 요건을 만족하는가? 자동 변환이 보정 비용을 압도할 만큼 생산성에 기여하는가? Data Understanding Wake up -&gt; 웨이크 업 항목 Translation(번역) Transliteration(독음) 고려대상 뜻이나 생각(의미) 가까운 소리 어순 바뀜 유지 주변 문맥 원거리 근거리 변환 난이도 대체로 어려움 상대적으로 쉬움 언어 소스 언어와 타겟 언어는 다름 소스 언어에 타겟 언어가 포함된 독음 엔진이 다양한 음운 현상을 커버할 수 있을까? 학습 데이터는 충분한가? Data Preparation 고품질의 학습 데이터를 생산하기 위한 데이터 전처리(분류, 분리, 제거, 변환 등등) 각 data 파일로부터 소스/타겟 데이터 분리하기 데이터 전처리 두 개 이상 가능한 독음 매핑 Modeling 분절(subword) 방식의 SPM(sentence piece model)과 LSTM기반 GNMT(Google Neural Machine Translation) Model SPM(sentence piece model) BPE기반의 알고리즘, 분절(subword unit)처리기로 띄어쓰기 오류 및 미등록(Out Of Vocabulary) 대응GNMT(Google Neural Machine Translation) 혼합(mixed) 언어 처리(Stacked residual LSTM) 분절(unsupervised) + 독음(supervised)의 2단계 혼합 프로세스 SPM은 학습할 Source/Target 언어를 분절단위(subword unit)로 분리 분절사전의 크기를 줄이면 OOV(Out Of Vocabulary) ↓, Bucket 용량 감소로 예측력 저하, 크기를 늘리면 OOV(Out Of Vocabulary) ↑, 예측력 증가 Sequence to sequence(seq2seq) Model Sequence to sequence(seq2seq) Model 번역기에서 대표적으로 사용되는 모델. 위 그림과 같이 seq2seq는 크게 인코더와 디코더 두 개의 아키텍처로 구성된다. 인코더는 입력 문장의 모든 단어들을 순차적으로 입력받은 뒤에 마지막에 이 모든 단어 정보들을 압축해서 하나의 벡터로 만드는데, 이를 컨텍스트 벡터(context vector) 라고 한다. 입력 문장의 정보가 하나의 컨텍스트 벡터로 모두 압축되면 인코더는 컨텍스트 벡터를 디코더로 전송한다. 디코더는 컨텍스트 벡터를 받아서 번역된 단어를 한 개씩 순차적으로 출력한다. [참조] https://wikidocs.net/24996 Beam Search 디코딩 기술 중 하나인 Beam Search는 최고 우선탐색(Best-First Search) 기법을 기본으로 하고 각 Step에서 확률이 높은 N개를 놓고 가장 높은 확률을 선택하는 방식이다. Evaluation 독음 결과를 인간이 고른 정답과 비교 1,000개 미등록(unseen) 테스트 세트에 대한 측정 결과 1-gram 기준 95.5% 의 정확도 달성 Deploymet 구현 결과 음성인식/대화에서의 품질 요건 충족 생산성에 크게 기여 자동화에 따른 생산성 향상 및 처리 비용 감소 생산성 6배 증가, 비용 86% 감소 Summary 의미 NMT 기술을 활용, 독음이라는 문제에 적용하여 고품질 및 차별적 기능을 달성 어려웠던 점 레퍼런스 부재 모델링보다는 오히려 데이터 정제 등의 전처리 과정에 대부분의 시간 투입 고품질의 데이터를 구축하기 위한 수작업 공수는 여전히 크다 서비스 POI, TV, Commerce 등 영역 확대 데이터 검증 인력과 기계와의 상호 과정 속에 반복학습이 가능한 데이터 선순환 체계 확립 필요 영역 확장 데이터만 확보된다면 의미 관계에 있는 다른 Task 적용 가능 기술적 진보는 우리로 하여금 모델링과 서비스에만 집중할 수 있게 도와줌 마지막으로 아래의 문장이 담긴 장으로 마무리하셨다. 많은 데이터를 가진 간단한 모델은 정교한 모델을 압도한다. 알고리즘이나 기술은 점점 개방화, 인프라 의존성 증가, 거대한 데이터를 수용 가능하게 발전해 왔다. 기술이나 사고방식보다는 데이터 자체가 소중해지는 시대다. 데이터의 양과 질 사이에서 타협점을 찾아야하는 고민은 계속된다. 제 수준에서 정말 어려운 부분이 많았고 정리하면서 하나씩 찾아가며 설명을 추가했기 때문에 정확하지 않을 수 있습니다… 🤔 마치며들은 내용 전부를 이해하지는 못했지만 관심 있는 분야라 그런지 열심히 들었다. 현직 개발자분들의 시행착오와 느낀점과 기술들을 알아볼 수 있어서 좋았다. 나도 나중에 저렇게 내가 했던 프로젝트를 발표하는 날이 올 때까지 더욱 열심히 해야겠다. 가장 기억에 남는 건 첫 번째 시간의 GiGA Genie Eco - AMK + GenieBlock, GiGA Genie Inside이다. AI MAKERS KIT을 가지고 나만의 GiGA Genie를 만들 수 있다니 기회가 된다면 꼭 만들어보고 싶다. 세 번째 시간부터는 어려운 내용이 있어서 이 글을 작성하면서도 알쏭달쏭하다. 모든 행사가 끝나고 추첨을 통해 경품을 나눠주셨다. 선착순 200명에겐 스타벅스 1만 원 상당 쿠폰과 550명에게 주는 선물은 전자 노트! KT S/W Developer Conference 2019를 통해 새로 알게 된 것들이 정말 많았다. 조금 아쉬웠던 점은 각각의 발표 사이에 전시 부스를 돌아볼 시간이 모자랐던 점! 눈으로만 호다닥 구경만 했다.👀 그래도 좋은 자리 마련해주신 KT 관계자분들 감사합니다.🙇🏻‍♂️ 앞으로도 많은 컨퍼런스에 참여해야겠다!","link":"/2019/08/30/2019-08-30-KT-S_W-Developer-Conference-2019/"},{"title":"Python으로 디스코드 봇 만들기","text":"한 번씩 디스코드를 쓰다가 봇에 대해 최근에 알게 되었다.많이 쓰는 기능인 노래 제공뿐만 아니라 다른 편의 사항도 제공해 줄 수 있을 것 같아 직접 제작해보기로 했다. 개발 언어는 Python이며, 코드 편집기는 PyCharm을 사용했다. 디스코드 봇 생성먼저 디스코드 개발자 페이지로 이동해서 계정을 생성해준다. 만약 창이 이렇게 보이지 않는다면 먼저 디스코드 회원가입부터 해주자.그리고 우측 상단의 New Application을 눌러준다. 이름, 설명, 아이콘 등 을 설정하고 우측 SETTINGS에서 BOT을 눌러준다. Add Bot을 눌러 봇을 생성한다.그리고 Click to Reveal Token을 눌러 나오는 코드를 복사해둔다. 토큰 복사 후 SETTINGS에서 OAuth2로 이동한다. OAuth2가 뭔지 궁금해서 찾아보니 아래와 같다. (구글 번역기야 고마워^^!) 응용 프로그램 개발자는 OAuth2를 통해 Discord API의 인증 및 데이터를 활용하는 응용 프로그램을 구축 할 수 있습니다.Discord에는 여러 유형의 OAuth2 인증이 있습니다.인증 코드 부여, 암시 적 부여, 클라이언트 자격 증명 및 봇 및 웹 후크에 대한 수정 된 특별 특별 흐름을 지원합니다. 아래로 스크롤을 내리면 SCOPES이 보이고 bot을 선택하면 아래와 같이 BOT PERMISSIONS가 추가로 보인다. {: width=”100%” height=”100%”} 봇에게 주고 싶은 권한을 체크하고 SCOPES안의 주소를 복사한다.참고로 나는 Send Messages와 Read Message History에 체크했다. 이후 디스코드 봇을 초대할 서버를 생성하고 복사한 주소로 접속한다. 복사한 주소로 접속한 후 만들어준 서버에 초대한다. 짜잔! 서버에 우리가 생성한 봇이 들어왔다. Python 코드 작성디스코드 봇을 파이썬으로 작성하기 편하게 제작된 모듈이 있는데 discord.py을 보고 참고하였다. 먼저 라이브러리를 설치해준다. 12#Windowspip install discord 나는 먼저 평소 라이브러리를 설치하듯이 위와 같이 설치했는데 다운로드 되는 것처럼 보이더니 코드에서 import 되지 않아서discord.py에 나온 방법으로 다시 설치했다. 12345# Linux/OS Xpython3 -m pip install -U discord.py# Windowspy -3 -m pip install -U discord.py 라이브러리를 설치하고 Python파일을 만들어 코드를 작성해준다.기존 자료들을 참고해서 코드를 작성했는데…Discord 모듈이 달라졌는지 코드가 안 먹혀서 이것저것 찾아보다 해결했다. https://discordpy.readthedocs.io/en/latest/api.html#참고한 사이트 12345678910111213141516171819202122232425262728import asyncioimport discordclient = discord.Client()# 생성된 토큰을 입력해준다.token = \"토큰\"# 봇이 구동되었을 때 보여지는 코드@client.eventasync def on_ready(): print(\"다음으로 로그인합니다\") print(client.user.name) print(client.user.id) print(\"================\")# 봇이 특정 메세지를 받고 인식하는 코드@client.eventasync def on_message(message): # 메세지를 보낸 사람이 봇일 경우 무시한다 if message.author.bot: return None if message.content.startswith('!안녕'): channel = message.channel await channel.send('반가워!')client.run(token) 코드를 작성하고 실행시킨다. 123다음으로 로그인합니다TunghsBot[CLIENT ID] 위와 같이 출력되면 성공! 디스코드 내에 봇이 온라인으로 바뀐 걸 볼 수 있다. 채팅창에 지정한 !안녕을 입력하면 반가워!라고 동작한다면 성공!! 이로써 간단히 디스코드 봇을 만들었다. 앞으로 Python의 여러 기능을 응용해 다양한 기능이 추가된 봇을 구현하려고 한다.","link":"/2019/08/08/2019-08-08-Make-a-Discord-Bot-with-Python/"},{"title":"Django Bootstrap 적용하기","text":"화면 구현Djagno 프로젝트와, 앱을 생성했다는 가정하에 시작한. 내 Django 프로젝트의 구조는 아래와 같다. 간단하게 모듈 디렉토리와 프로젝트 디렉토리 구조만 첨부했다. 12345678910111213141516WebTest/├── .idea/├── community/│ ├── migrations│ ├── __init__.py│ ├── admin.py│ ├── apps.py│ ├── forms.py│ ├── tests.py│ └── views.py├── venv/└── WebTest/ ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py 템플릿을 추가하기 위해 WebTest/community아래에 templates라는 이름의 디렉토리를 생성해준다. 그리고 index.html 파일을 생성한다. 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 메인페이지 &lt;/body&gt;&lt;/html&gt; 간단하게 템플릿을 만들어 준다. 그리고 뷰를 하나 생성해보겠다. 먼저 views.py 파일을 열어주고 아래 내용을 추가한다. 12345from django.shortcuts import render# Create your views here.def index(request): return render(request, 'index.html') views.py는 아까 생성한 index.html 템플릿을 불러와서 보여준다. 여기까지 끝났다면 WebTest/WebTest/url.py에 접속할 url을 설정한다. 123456789from django.contrib import adminfrom django.conf.urls import include, urlfrom community.views import *urlpatterns = [ url('admin/', admin.site.urls), # 아래 코드르 추가해준다. url('', index, name='index')] 이제 커맨드에서 manage.py가 있는 WebTest/WebTest디렉토리로 이동해 서버를 실행시켜준다. 1python manage.py runserver 바뀐 화면을 확인하기 위해 서버를 실행시켜준다. 템플릿이 적용된걸 확인하고 커맨드에서 Ctrl + c를 누르면 서버가 종료된다. 부트스트랩(Bootstrap) 부트스트랩(Bootstrap)부트스트랩은 웹사이트를 쉽게 만들 수 있게 도와주는 HTML, CSS, JS 프레임워크이다. 하나의 CSS 로 휴대폰, 태블릿, 데스크탑까지 다양한 기기에서 작동한다. 다양한 기능을 제공하여 사용자가 쉽게 웹사이트를 제작, 유지, 보수할 수 있도록 도와준다.[출처]위키백과 부트스트랩을 JSP로 웹페이지를 만들었을 때도 잘 써서 이번에도 이용하려고 한다. 먼저 부트스트랩 사이트로 이동하자.각각의 필요한 부분 하나하나씩 넣어가면 만들어도 좋지만 간단하게 Examples에 있는 Blog를 적용하려고 한다. Examples에 들어가면 상단에 Download source code를 눌러 bootstrap 파일을 받아서 적용하려고 했는데 뭔가 조금 달라서 그냥 Blog의 HTML을 긁어서 index.html에 넣고 사용했다. index.html을 수정해주었다면 Django에서 js, css, 이미지 등의 파일들을 Static 파일이라 부르는데 이 파일들을 관리해줄 폴더를 생성한다. Django 프로젝트 내부 WebTest/community아래에에 static 디렉토리를 생성한다. 그리고 프로젝트가 static 폴더를 찾아갈 수 있게 설정을 추가한다. WebTest/WebTest내에 settings.py에 맨 아랫줄에 아래와 같이 코드를 추가해준다. 1STATIC_ROOT = os.path.join(BASE_DIR, 'static') 마지막으로 static의 경로를 템플릿에서 인식할 수 있게 index.html 상단에 코드를 추가한다. 12345{% load staticfiles %}&lt;DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; ： 여기까지 하고 서버를 실행시켜주면 부트스트랩이 적용된 것을 볼 수 있다.","link":"/2019/09/07/2019-09-07-Apply-Django-Bootstrap/"},{"title":"Python 파일 입출력","text":"DB 데이터 입출력을 하기 전에 테스트용으로 Python에서 파일 입출력하는 법을 알아보려고 한다. 이 글은 점프 투 파이썬 을 참고했다. 파일 생성파일을 생성하기 위해 Python의 내장함수인 open을 사용한다. open 함수는 파일 이름과 파일 열기 모드를 입력받아 현재 위치한 디렉토리에 파일을 생성한다. 12f = open(\"text.txt\",'w')f.close() 파일 객체 = open(파일이름, 파일 열기 모드) 파일 열기 모드의 종류는 다음과 같다. 파일 열기 모드 설명 r 파일을 읽기만 할 때 사용 w 파일에 내용을 쓸 때 사용 a 파일의 마지막에 새로운 내용을 추가할 때 사용 파일 읽기파일을 읽는 방법은 readline()과 readlines() 그리고 read가 있다. readline() readline()은 파일을 열고 첫번째 줄을 출력한다. 123f = open(\"test.txt\", 'r')line = f.readline()f.lose() 무한루프를 이용해 모든줄을 읽어 출력할 수 있다. 12345f = open(\"text.txt\", 'r')while True: line = f.readline() if not line: break f.close() readlines() readlines()는 파일의 모든 줄을 읽어 각각의 줄을 요소로 갖는 리스트로 만들어준다. 12345f = open(\"test,txt\", 'r')lines = f.readlines()for line in lines: print(line)f.close() read() read()는 파일 내용 전체를 문자열로 돌려준다. 1234f = open(\"text.txt\", 'r')data = f.read()print(data)f.close() with위의 예제들에서는 항상 파일을 열어준 후 f.close()로 닫았다. 그러나 with문은 이렇게 파일을 열고 닫는 것을 자동으로 처리할 수 있게 해준다. 12with open(\"text.txt\", 'w') as f: f.write(\"Python test\") 이렇게 with문을 사용하면 with 블록을 벗어나는 순간 열렸던 파일이 자동으로 close 된다.","link":"/2019/09/16/2019-09-16-Python-File-IO/"},{"title":"Hexo 블로그 포스팅에 Flowchart 사용하기","text":"Hexo Flowchart 플러그인블로그 포스팅을 하면서 순서도가 필요할때가 있을 것 같아 그림으로 넣어야하나 고민했는데 플러그인이 있어서 적용해 봤다.👏 Flowchart 플러그인 적용서Markdown 플러그인 확인Flowchart 플러그인을 적용해 주기 전에 먼저 한가지 확인해야 할게 있다.Hexo 기본 Markdown 플러그인은 hexo-renderer-marked이다. 나는 hexo-renderer-markdown-it이라는 플러그인을쓰고있었는데 Flowchart 플러그인이 적용되지 않아서 기본플러그인 hexo-renderer-marked으로 변경하니 적용되었다.Flowchart 플러그인은 기본 플러그인만 적용되는것 같다. 플러그인 확인Hexo Blog 폴더에 _config.yml파일과 같은 경로에 존재하 package.json에서 플러그인을 확인 할 수 있다.아래는 내 Hexo Blog의 패키지다. 12345678910111213141516171819202122{ \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": { \"version\": \"3.9.0\" }, \"dependencies\": { \"hexo\": \"^3.9.0\", \"hexo-auto-canonical\": \"^0.1.1\", \"hexo-deployer-git\": \"^1.0.0\", \"hexo-filter-flowchart\": \"^1.0.4\", \"hexo-generator-archive\": \"^0.1.5\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-index\": \"^0.2.1\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-renderer-ejs\": \"^0.3.1\", \"hexo-renderer-marked\": \"^2.0.0\", //Markdown 플러그인 \"hexo-renderer-stylus\": \"^0.3.3\", \"hexo-server\": \"^0.3.3\" } } 만약 Flowchart 플러그인이 적용되지 않는다면 아래와 같이 기본 플러그인으로 변경해주자 12$ npm un [설치된 플러그인] -- save$ npm i hexo-renderer-marked -- save Flowchart 플러그인Markdown 플러그인을 확인했다면 Flowchart 플러그인을 설치한다. hexo-filter-flowchart 플러그인은 Markdown에서 순서도 기능을 지원해준다. hexo-filter-flowchart플러그인을 만든 *bubkoo**(https://github.com/bubkoo/hexo-filter-flowchart)님의설명을 참고했다. hexo-filter-flowchart 플러그인의 설치는 명령어는 아래와 같다. 1$ npm install --save hexo-filter-flowchart 이제 설치가 되었다면 사용해보자. 1234567891011121314151617```(flow)st=&gt;start: Start|past:&gt;http://www.google.com[blank]e=&gt;end: End:&gt;http://www.google.comop1=&gt;operation: My Operation|pastop2=&gt;operation: Stuff|currentsub1=&gt;subroutine: My Subroutine|invalidcond=&gt;condition: Yesor No?|approved:&gt;http://www.google.comc2=&gt;condition: Good idea|rejectedio=&gt;inputoutput: catch something...|requestst-&gt;op1(right)-&gt;condcond(yes, right)-&gt;c2cond(no)-&gt;sub1(left)-&gt;op1c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e``` 현재 나의 Hexo 테마의 마크다운에서는 지원을 안해주는지 어떻게 쓰던 flow만 쓰면 코드가 보이지 않아서 괄호를 넣어줬다.사용할 때는 꼭 괄호를 제거해줘야한다. 123456789101112131415st=&gt;start: Start|past:&gt;http://www.google.com[blank]e=&gt;end: End:&gt;http://www.google.comop1=&gt;operation: My Operation|pastop2=&gt;operation: Stuff|currentsub1=&gt;subroutine: My Subroutine|invalidcond=&gt;condition: Yesor No?|approved:&gt;http://www.google.comc2=&gt;condition: Good idea|rejectedio=&gt;inputoutput: catch something...|requestst-&gt;op1(right)-&gt;condcond(yes, right)-&gt;c2cond(no)-&gt;sub1(left)-&gt;op1c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e 이렇게 위와 같이 Flowchart가 생성된다.다만 한가지 단점은 svg파일로 생성되기 때문에 나의 모자란 프론트 지식으론 css를 만져도반응형 웹에 맞게 크기 조절을 하지못했다. 조금 더 찾아봐야겠지만 플러그인을 사용해서 Flowchart를생성하면 svg 이미지의 기본값이 적용되어있는것 같다. pc나 태블릿등에선 보기 괜찮지만 상대적으로 크기가 작은 스마트에서는 보기 불편할 것 같다. 추후 설정을 만져봐야겠다. 🙄 SVG스케일러블 벡터 그래픽스(Scalable Vector Graphics, SVG)는 2차원 벡터 그래픽을 표현하기 위한 XML 기반의 파일 형식으로, 1999년 W3C(World Wide Web Consortium)의 주도하에 개발된 오픈 표준의 벡터 그래픽 파일 형식이다.위키백과 참조","link":"/2019/10/14/2019-10-14-Hexo-Blog-Graph/"},{"title":"Git Blog 다시 시작","text":"정말 오랜만에 깃블로그를 작성한다… 처음 내가 공부한 내용을 남기려고 깃블로그를 만들었었다. 생각보다 글 하나 쓰는데 시간이 많이 소요되어서 다음에 쓰자… 쓰자 하다 보니 이렇게 시간이 지나버렸다.특히 깃블로그를 운영한지 얼마 되지 않고 운이 좋게 인턴에 합격해서 시간가는줄 몰랐다…그래서 오늘을 기점으로 다시 블로그에 공부한 내용을 포스팅하려고 한다.현재 회사에서 C#을 하고 있기에 주로 포스팅은 C#, MVVM패턴이 대부분이고 이외에 OpenCV와 Python을 업로드하려고한다. 앞으로 공부하는 내용은 느리더라고 꾸준하게 블로그에 올리면서 블로그를 채워가야겠다.","link":"/2020/05/07/2020-05-07-Git-Blog-%EB%8B%A4%EC%8B%9C%EC%8B%9C%EC%9E%91/"},{"title":"Hexo Icarus 테마 인라인 코드 블럭 색상 수정하기","text":"Git Blog 테마를 Icarus로 변경하고 몇몇 부분을 수정하면서 제일 변경하고 싶었던 것 중 하나인 인라인 코드 블럭(Inline Code Block)을 변경하고 싶어서 이것저것 뜯어보다가 발견했다. 먼저 인라인 코드 블럭(Inline Code Block)은 인용문, 강조 할 때 쓰는 Markdown 문법 중 하나다. 인라인 코드 블럭(Inline Code Block)을 변경하기 위해서는 themes/icarus/source/css/style.styl 파일에서 아래와 같이 수정해 주면 된다. 다만 작년에 블로그를 개설했기 때문에 지금 버전의 Icarus 테마 구조와 다른 것 같다. themes/icarus/source/css/style.styl1234567891011&amp; &gt; code, :not(pre) &gt; code font-size: 0.85em /* 변경할 글자 색상 */ color: hsl(348, 100%, 61%) /* 아래는 배경 관련 설정 */ background-color: hsl(60, 1%, 97%) padding: 3px 5px margin: 0 2px border-radius: 2px white-space: nowrap 웹은 문외한이라 이것저것 만져보다가 확인하려고 새로 고침을 딱 눌렀는데 원하던 부분이 변경되었을 때의 희열감이 너무 좋다. 😂","link":"/2020/05/09/2020-05-09-Hexo-Icarus-Theme-Inline-Code-Block-Style-Change/"},{"title":"WPF MVVM DataGrid 동적으로 사용하기","text":"DataGrid를 동적으로 변경하며 결과를 보여줄 일이 생겼다. 다만 평소에는 DataGrid에 ObservableCollection을 바인딩해서 사용했기 때문에 항상 컬럼값은 고정이었는데, DataTable을 바인딩하면 동적으로 변경 가능하다고 해서 적용해봤다. 예시로 아래와 같이 UI 구성하고 Run 버튼을 누르면 TextBox에 입력된 숫자만큼 컬럼이 생성되는 프로그램을 간단히 만들었다. 먼저 해당 View의 .xaml에서 DataGrid에 아래와 같이 DataTable을 바인딩한다. 12345&lt;DataGrid IsReadOnly=\"True\" ColumnWidth=\"*\" AutoGenerateColumns=\"True\" VirtualizingStackPanel.IsVirtualizing =\"True\" ItemsSource=\"{Binding DataTable, UpdateSourceTrigger=PropertyChanged}\"&gt;&lt;/DataGrid&gt; 다음은 ViewModel에 DataGrid를 선언해 주면 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142// UI Variableprivate DataTable _DataTable;public DataTable DataTable{ get =&gt; _DataTable; set =&gt; Set(ref _DataTable, value);}// 컬럼 개수를 받아오기 위해 TextBox에 바인딩private string _ColumnCount;public string ColumnCount{ get =&gt; _ColumnCount; set =&gt; Set(ref _ColumnCount, value);} . . .// DataTable 변경public void ChangeDataTable(){ DataTable dt = new DataTable(); // 입력한 컬럼 개수만큼 Column 생성 int columnCount = int.Parse(ColumnCount); for(int index = 0; index &lt; columnCount; index++) { dt.Columns.Add($\"INDEX {index}\", typeof(string)); } // Row 추가 DataRow row = dt.NewRow(); for (int index = 0; index &lt; columnCount; index++) { row[index] = $\"{index}\"; } dt.Rows.Add(row); DataTable = dt;} 코드를 작성하면 아래와 같이 잘 동작한다. 이후 실제 사용하려는 프로젝트에 적용했었는데 DataTable이 업데이트가 안되는 문제가 생겼다. 분명 똑같이 사용했고 코드에 문제도 없다고 생각되었는데… 이것저것 만져보다가 혹시나 해서 컬럼명에 사용했던 특수문자를 제거하니 DataTable이 제대로 업데이트 되었다. 몇번의 테스트 후 내린 결론은 컬럼명에 특수문자가 포함되어 있다면 DataTable이 업데이트되지 않는 문제가 발생하는 것 같다.","link":"/2020/10/25/2020-10-25-WPF-Dynamic-Datagrid/"}],"tags":[{"name":"Conference","slug":"Conference","link":"/tags/Conference/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"post","slug":"post","link":"/tags/post/"}],"categories":[{"name":"Conference","slug":"Conference","link":"/categories/Conference/"},{"name":"Dev","slug":"Dev","link":"/categories/Dev/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Etc","slug":"Etc","link":"/categories/Etc/"},{"name":"Python","slug":"Dev/Python","link":"/categories/Dev/Python/"},{"name":"WPF","slug":"Dev/WPF","link":"/categories/Dev/WPF/"}]}